\subsection{GROOVE: Modelling and analysis Tool}\label{groove}
Graphs in groove consist of labelled nodes and edges. An edge is a binary arrow between two nodes. Node labels can either be node types or ﬂags; the latter can be used to model a Boolean condition, which is true for a node if the ﬂag is there and false if it is absent.

GROOVE can work either in an untyped or in a typed mode. In the untyped mode, graphs can be arbitrary: there are no constraints on the allowed combinations of node types, ﬂags and edges. In the typed mode, all graphs and rules must be well-typed, meaning that they can be mapped into a special type graph. This is checked statically for the start graph and the rules: the theory then ensures that well-typedness is preserved under transformation. The type graph determines the allowed combinations of node types and edges \cite{ghamarian2012modelling}.\\ 
\textbf{Rules and Application Condition}\\ 
Graphs are transformed by applying rules. A rule consists of the following:
\begin{itemize}
\item A pattern that must be present in the host graph in order for the rule to be applicable
\item Subpatterns that must be absent in the host graph in order for the rule to be applicable
\item Elements (nodes and edges) to be deleted from the graph
\item Elements (nodes and edges) to be added to the graph
\item Pairs of nodes that are to be merged
\end{itemize}
All these elements are combined into a single graph; colors and shapes are used to distinguish them. Ghamarian et al. distinguish positive (which must be present in order to apply a rule) and negative (which must be absent in order to apply a rule) ones, whereas of the latter, Ghamarian et al. distinguish deletion and creation of elements. Figure \ref{fig:groove_legend} shows a small example illustrating most of these concepts:
\begin{figure}
\center
\includegraphics[width=11.03cm, height=4.0cm]{groove_legend}
\caption{Example GROOVE rule and legend  \cite{ghamarian2012modelling} }\label{fig:groove_legend}
\end{figure}
\begin{itemize}
\item The black (continuous thin) \enquote{reader} elements, in this case two nodes labelled \textbf{A} and \textbf{C}, must be present and are preserved—in fact, they form a positive application condition.
\item The \textcolor{red}{red} (dashed fat) \enquote{embargo} elements, in this case a \textbf{parent}-labelled edge with a \textbf{P}-labelled target node, must be absent in the graph—in fact, each connected subgraph of embargo elements forms a negative application condition.
\item The \textcolor{blue}{blue} (dashed thin) \enquote{eraser} elements, in this case a \textbf{child}-labelled edge from the \textbf{A}-node to the \textbf{C}-node, must be present and are deleted.
\item The \textcolor{green}{green} (continuous fat) \enquote{creator} elements, in this case a parent-labelled edge with a \textbf{P}-labelled target node, are created.
\end{itemize}
The overall effect of the rule is to search for \emph{\textbf{A}}- and \emph{\textbf{C}}-nodes connected by a \emph{\textbf{child}}-edge but without a \emph{\textbf{parent}}-edge to a \emph{\textbf{P}}-node, and to modify this by removing the \emph{\textbf{child}}-edge and adding a \emph{\textbf{parent}}-edge to a fresh \emph{\textbf{P}}-node.

 For instance, the rule can be applied to the graph on the left-hand side of Figure \ref{fig:groove_example}  in two ways, one of which result in the graph on the right-hand side. (The other application removes the other \emph{\textbf{child}}-edge.)

The core functionality of GROOVE is to recursively apply all rules from a predeﬁned set (the graph transformation system) to a given start graph, and to all graphs generated by such applications. This results in a state space consisting of the generated graphs. The strategy according to which the state space is explored (\emph{e.g.}, depth-ﬁrst, breadth-ﬁrst or linear) can be set as a parameter \cite{ghamarian2012modelling}.
\begin{figure}
\center
\includegraphics[width=9.73cm, height=4.79cm]{groove_example}
\caption{Example application of the rule in Figure \ref{fig:groove_legend}}\label{fig:groove_example}
\end{figure}\\ 
\textbf{Attributes}\\ 
Nodes in a graph typically stand for instances of some resource or concept. It is also necessary to include data ﬁelds, containing Booleans, integer numbers or strings. Such data ﬁelds are usually called \emph{attributes}. 

GROOVE supports attributes by treating them as special edges that do not point to a standard node, but to a node that corresponds to a data value. Graphically, such edges are usually represented by expressions of the form \enquote{x = 12}, rather than by x-labelled arrows pointing to a $12-labelled$ node.\\ 
\textbf{Regular expressions}\\
Besides ordinary edges, a rule may include edges carrying regular expressions. These will be matched in the host graph by searching for a path whose labels satisfy the regular expression. 

This especially allows the speciﬁcation of cycles or the transitive closure of edges. Regular expressions may also contain \emph{wildcards}, which are matched by any label in a given set. Moreover, wildcard may be \emph{named}; such a name is effectively a variable for edge labels.\\ 
\textbf{Quantiﬁcation}\\ 
One of the special features of GROOVE is the support of universal quantiﬁcation in rules \cite{rensink2009repotting}. A universally quantiﬁed (sub)rule is one that will be applied to all subgraphs that satisfy the relevant application conditions, rather than just a single one as in the standard case. 

Such a rule can itself be much more concise, and also result in a smaller state space, then the equivalent set of rules that would ordinarily be needed. In fact, quantiﬁcation can be nested in the sense that universally quantiﬁed rules can contain further existential subrules, and vice versa. Among other things, this makes it possible to formulate powerful application conditions \cite{rensink2004representing}.\\ 
\textbf{Control}\\ 
The standard behavior of GROOVE is to attempt the application of arbitrary rules at any point in time. There are, however, two further methods to control and direct the application of rules. A most straightforward mechanism is to assign \emph{priorities} to rules: low-priority rules may only be applied if no higher-priority rule is applicable. A more sophisticated mechanism is to use GROOVE’s \emph{control language}.
A control program is imposed on top of a graph transformation system and speciﬁes the allowed order of application of the rules of that system, referring to the rules by name. 

For instance, the control program \emph{a}; try \{b;\} else \{c;\} speciﬁes that ﬁrst the rule named \enquote{a} must be applied, after which \enquote{b} is tried; if \enquote{b} is not applicable, \enquote{c} is applied. If rule \enquote{a} is not applicable in the beginning, then nothing happens. Other constructs offered by the language include:
\begin{itemize}
\item Looping, including an \enquote{as-long-as-possible} construct
\item A random choice between rules
\item Simple (noun-recursive) function calls
\end{itemize}
\textbf{State space exploration}\\ 
The most distinguishing feature of GROOVE, compared with another graph transformation tools, is the fact that it does not just carry out a single sequence of transformations from a given start state, but can explore and store the entire state space of reachable graphs. This provides a rich source of information for further analysis. In fact, GROOVE offers a choice of the exploration strategy to be used:
\begin{itemize}
\item Depth-ﬁrst full exploration, also with on-the-ﬂy Linear Temporal Logic model checking
\item Breadth-ﬁrst full exploration. In some grammars, this enables ﬁnding shortest paths to certain graphs
\item Linear, random linear, and conditional exploration. This allows simulation without covering all states, for instance if the state space is too large.
\end{itemize}
In \cite{lucassen2016improving} Kleppe et al. describe the execution semantics of a simple object-oriented programming language in terms of graph transformation rules. A program graph is used as input and each rule application simulate the execution of a program instruction. By means of GROOVE’s state space exploration capabilities, it is possible to generate ﬁnite execution traces of a program and model check for errors. In this setting, GROOVE can be seen as a non-deterministic execution engine for the language deﬁned by the transformation rules.

GROOVE can provide a great assistance in analyzing US, where non-determinism as well as parallelism is an essential part. However, the problem does not scale in GROOVE for problems with large sizes. This is because the size of the state space grows dramatically as the ring size increases. This is the well-known state space explosion problem, common to all model checking tools \cite{rensink2004representing}.
\begin{example}\label{groove_example}
To exemplify model checking in GROOVE, we consider a finite transition system consisting of two USs, $US_1$:\enquote{As an Administrator, I am able to add a new person to the database} and  $US_2$: \enquote{As a Visitor, I am able to view a person’s proﬁle}. The application of typed graph and transformation rules, as depicted in Figure \ref{fig:groove_transformation_rules}, utilizing two transformation rules: one corresponds to $US_1$ named $add\_person$; it serves the purpose of saving a Profile in the database when there is no existing Profile (corresponding to specific Person in the database). Another rule corresponding to $US_2$ named $view\_profile$ is responsible for adding a \enquote{view} edge between Visitor and the DB nodes if a Profile (corresponding to the Person) already exists in the database. AS we can see both rules are typed according to defined type graph .As start graph we choose the existent of four Element namely Admin, DB, Visitor and Profile.
\begin{figure}
\center
\includegraphics[height=7.5cm,width=13.3cm]{groove_typed_graph}
\includegraphics[height=4.5cm,width=5.3cm]{groove_start_graph}
\includegraphics[height=5cm,width=5.43cm]{groove_rule_view_profile}
\includegraphics[height=5.5cm,width=8cm]{groove_rule_add_person}
\caption{Provided Type-Graph, Start Graph and Transformation Rules for $US_1$ and $US_2$ } \label{fig:groove_transformation_rules}
\end{figure}
\begin{figure}
\center
\includegraphics[width=14.0cm, height=2.3cm]{groove_model_checking}
\caption{Application of GROOVE model checking to Analyze Transformation Rules and a finite transition system for two USs }\label{fig:groove_model_checking}
\end{figure}
\end{example}
The application of GROOVE model checking to analyze transformation rules and a finite transition system is illustrated in Figure \ref{fig:groove_model_checking}. As we can see, GROOVE found only a single sequence of transformation, which means, $US_2$ cannot proceed without execution and consideration of $US_1$ due to lack of \textbf{save}-edge between \textbf{Profile}-node and \textbf{DB}-node. 

\input{Section/GTS_Henshin}
